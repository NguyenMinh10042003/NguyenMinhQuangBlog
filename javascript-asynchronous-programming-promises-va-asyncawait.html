<!DOCTYPE html><html lang="vi"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><title>JavaScript Asynchronous Programming (Promises và Async/Await) - NguyenMinhQuangBlog</title><meta name="description" content="JavaScript Asynchronous Programming là một khái niệm quan trọng trong phát triển web, giúp xử lý các tác vụ tốn&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/javascript-asynchronous-programming-promises-va-asyncawait.html"><link rel="alternate" type="application/atom+xml" href="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/feed.xml"><link rel="alternate" type="application/json" href="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/feed.json"><meta property="og:title" content="JavaScript Asynchronous Programming (Promises và Async/Await)"><meta property="og:image" content="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/media/posts/11/1_wdNsCBMAtWRkT7ppVEVf0Q.png"><meta property="og:image:width" content="1400"><meta property="og:image:height" content="700"><meta property="og:site_name" content="NguyenMinhQuangBlog"><meta property="og:description" content="JavaScript Asynchronous Programming là một khái niệm quan trọng trong phát triển web, giúp xử lý các tác vụ tốn&hellip;"><meta property="og:url" content="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/javascript-asynchronous-programming-promises-va-asyncawait.html"><meta property="og:type" content="article"><link rel="shortcut icon" href="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/media/website/315051163_676409890517089_7907966800036286213_n.jpg" type="image/x-icon"><link rel="stylesheet" href="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/assets/css/fontawesome-all.min.css?v=85514f933f9e0b82460af63f1a403fa5"><link rel="stylesheet" href="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/assets/css/style.css?v=b998987fcd790827121deaee98e92c30"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/javascript-asynchronous-programming-promises-va-asyncawait.html"},"headline":"JavaScript Asynchronous Programming (Promises và Async/Await)","datePublished":"2024-12-30T20:34+07:00","dateModified":"2024-12-30T20:34+07:00","image":{"@type":"ImageObject","url":"https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/media/posts/11/1_wdNsCBMAtWRkT7ppVEVf0Q.png","height":700,"width":1400},"description":"JavaScript Asynchronous Programming là một khái niệm quan trọng trong phát triển web, giúp xử lý các tác vụ tốn&hellip;","author":{"@type":"Person","name":"Nguyen Minh Quang","url":"https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/authors/nguyen-minh-quang/"},"publisher":{"@type":"Organization","name":"Nguyen Minh Quang"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="is-preload post-template"><div id="wrapper"><div id="main"><div class="inner"><header id="header"><a class="logo" href="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/"><strong>NguyenMinhQuangBlog</strong></a><ul class="icons"><li><a href="https://www.facebook.com/nguyen.minh.609002/" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li></ul></header><article class="post"><header class="main post__header"><time datetime="2024-12-30T20:34" class="post__date">tháng 12 30, 2024</time><h1>JavaScript Asynchronous Programming (Promises và Async/Await)</h1></header><figure class="image main"><img src="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/media/posts/11/1_wdNsCBMAtWRkT7ppVEVf0Q.png" srcset="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/media/posts/11/responsive/1_wdNsCBMAtWRkT7ppVEVf0Q-xs.png 300w, https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/media/posts/11/responsive/1_wdNsCBMAtWRkT7ppVEVf0Q-sm.png 480w, https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/media/posts/11/responsive/1_wdNsCBMAtWRkT7ppVEVf0Q-md.png 768w, https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/media/posts/11/responsive/1_wdNsCBMAtWRkT7ppVEVf0Q-lg.png 1024w, https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/media/posts/11/responsive/1_wdNsCBMAtWRkT7ppVEVf0Q-xl.png 1360w, https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/media/posts/11/responsive/1_wdNsCBMAtWRkT7ppVEVf0Q-xxl.png 1600w" sizes="(max-width: 1600px) 100vw, 1600px" loading="lazy" height="700" width="1400" alt=""></figure><div class="post__inner post__entry"><p><strong>JavaScript Asynchronous Programming</strong> là một khái niệm quan trọng trong phát triển web, giúp xử lý các tác vụ tốn thời gian (như gọi API, đọc tệp tin, hoặc truy vấn cơ sở dữ liệu) mà không làm gián đoạn luồng chính của ứng dụng. JavaScript cung cấp một số phương thức để làm việc với các tác vụ bất đồng bộ, trong đó <strong>Promises</strong> và <strong>Async/Await</strong> là hai kỹ thuật phổ biến và mạnh mẽ.</p><h3>1. <strong>Promises</strong></h3><p><strong>Promise</strong> là một đối tượng đại diện cho một giá trị có thể có trong tương lai. Promise giúp bạn xử lý các tác vụ bất đồng bộ bằng cách sử dụng các phương thức <code>then()</code>, <code>catch()</code>, và <code>finally()</code>.</p><h4>Các trạng thái của Promise:</h4><ul><li><strong>Pending</strong>: Trạng thái ban đầu, khi tác vụ chưa hoàn tất.</li><li><strong>Resolved (Fulfilled)</strong>: Trạng thái khi tác vụ hoàn thành thành công.</li><li><strong>Rejected</strong>: Trạng thái khi tác vụ thất bại.</li></ul><h4>Các phương thức của Promise:</h4><ul><li><strong>then()</strong>: Được gọi khi Promise được hoàn thành (được resolve).</li><li><strong>catch()</strong>: Được gọi khi Promise bị lỗi (rejected).</li><li><strong>finally()</strong>: Được gọi sau khi Promise đã hoàn thành, bất kể thành công hay thất bại.</li></ul><h4>Ưu điểm của Promise:</h4><ul><li><strong>Xử lý bất đồng bộ</strong> theo cách rõ ràng và dễ hiểu hơn so với callback truyền thống.</li><li><strong>Dễ dàng xử lý lỗi</strong> bằng cách sử dụng <code>catch()</code>.</li><li><strong>Hỗ trợ chuỗi Promise</strong>: Bạn có thể nối nhiều tác vụ bất đồng bộ lại với nhau mà không cần lồng callback.</li></ul><h3>2. <strong>Async/Await</strong></h3><p><strong>Async/Await</strong> là cú pháp mới hơn trong JavaScript (được giới thiệu trong ES2017) giúp viết mã bất đồng bộ dễ dàng hơn, trông giống như mã đồng bộ nhưng vẫn giữ khả năng xử lý bất đồng bộ.</p><h4>Cú pháp:</h4><ul><li><strong>async</strong>: Khi một hàm được khai báo là <code>async</code>, nó luôn trả về một Promise. Bên trong hàm <code>async</code>, bạn có thể sử dụng <code>await</code> để chờ kết quả từ các Promise.</li><li><strong>await</strong>: Được sử dụng trong một hàm <code>async</code> để chờ kết quả từ một Promise. <code>await</code> làm cho JavaScript chờ cho đến khi Promise được hoàn thành và sau đó tiếp tục thực thi.</li></ul><h4>Ưu điểm của Async/Await:</h4><ul><li><strong>Mã dễ đọc hơn</strong>: Async/Await giúp mã bất đồng bộ trông giống như mã đồng bộ, dễ hiểu và dễ bảo trì hơn, đặc biệt là khi xử lý chuỗi các tác vụ bất đồng bộ.</li><li><strong>Quản lý lỗi tốt hơn</strong>: Bạn có thể sử dụng <code>try/catch</code> để xử lý lỗi trong các tác vụ bất đồng bộ, giống như với mã đồng bộ.</li><li><strong>Dễ dàng kết hợp với Promises</strong>: <code>async/await</code> vẫn sử dụng Promises ở phía dưới, nhưng giúp bạn viết mã sạch sẽ và dễ dàng hơn.</li></ul><h3>3. <strong>Sự khác biệt giữa Promises và Async/Await</strong></h3><table><thead><tr><th>Tính năng</th><th><strong>Promises</strong></th><th><strong>Async/Await</strong></th></tr></thead><tbody><tr><td><strong>Cú pháp</strong></td><td>Sử dụng <code>.then()</code>, <code>.catch()</code>, <code>.finally()</code></td><td>Sử dụng <code>async</code> và <code>await</code></td></tr><tr><td><strong>Quản lý lỗi</strong></td><td>Dùng <code>.catch()</code></td><td>Dùng <code>try/catch</code></td></tr><tr><td><strong>Đọc mã</strong></td><td>Có thể khó hiểu khi chuỗi Promise dài</td><td>Mã dễ đọc hơn, gần giống đồng bộ</td></tr><tr><td><strong>Xử lý nhiều Promise</strong></td><td>Có thể dùng <code>Promise.all()</code> hoặc <code>Promise.allSettled()</code></td><td>Dùng vòng lặp <code>for</code> hoặc <code>forEach</code> kết hợp với <code>await</code></td></tr><tr><td><strong>Hỗ trợ đồng bộ hóa</strong></td><td>Không hỗ trợ trực tiếp</td><td>Cho phép mã bất đồng bộ trông như đồng bộ</td></tr></tbody></table><div class="contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950"><div class="overflow-y-auto p-4" dir="ltr"> </div></div><h3>4. <strong>Các phương thức bổ sung khi làm việc với Promises</strong></h3><ul><li><strong><code>Promise.all()</code></strong>: Chạy nhiều Promise song song và chờ tất cả hoàn thành.</li><li><strong><code>Promise.race()</code></strong>: Chạy nhiều Promise song song và lấy kết quả của Promise đầu tiên hoàn thành.</li><li><strong><code>Promise.allSettled()</code></strong>: Chờ tất cả các Promise hoàn tất (dù thành công hay thất bại), trả về kết quả của từng Promise.</li><li><strong><code>Promise.any()</code></strong>: Chạy nhiều Promise và trả về kết quả của Promise đầu tiên thành công.</li></ul><h3>5. <strong>Tại sao sử dụng Async/Await thay vì Promises thông thường?</strong></h3><ul><li><strong>Dễ đọc hơn</strong>: Khi làm việc với các chuỗi Promise dài, sử dụng <code>async/await</code> giúp mã dễ hiểu hơn và tránh "callback hell".</li><li><strong>Quản lý lỗi hiệu quả hơn</strong>: Việc xử lý lỗi trở nên trực quan hơn khi sử dụng <code>try/catch</code> với <code>async/await</code>.</li><li><strong>Giảm thiểu mã lặp lại</strong>: <code>async/await</code> giúp bạn giảm bớt các chuỗi <code>then()</code> lồng nhau và dễ dàng tái sử dụng mã.</li></ul><h3>Kết luận:</h3><ul><li><strong>Promises</strong> là cách tiếp cận mạnh mẽ để xử lý bất đồng bộ trong JavaScript và hỗ trợ chuỗi các tác vụ bất đồng bộ mà không gây chồng chéo mã.</li><li><strong>Async/Await</strong> là cú pháp cải tiến, giúp viết mã bất đồng bộ trông giống như mã đồng bộ, dễ đọc và bảo trì hơn, đồng thời vẫn giữ được các tính năng mạnh mẽ của Promises.</li></ul></div><footer class="post__inner post__footer"><p class="post__last-updated">This article was updated on tháng 12 30, 2024</p><div class="post__share"><h3>Share post:</h3><a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2FNguyenMinh10042003.github.io%2FNguyenMinhQuangBlog%2Fjavascript-asynchronous-programming-promises-va-asyncawait.html" class="js-share icon brands fa-facebook" rel="nofollow noopener noreferrer"><span class="label">Facebook</span> </a><a href="https://pinterest.com/pin/create/button/?url=https%3A%2F%2FNguyenMinh10042003.github.io%2FNguyenMinhQuangBlog%2Fjavascript-asynchronous-programming-promises-va-asyncawait.html&amp;media=https%3A%2F%2FNguyenMinh10042003.github.io%2FNguyenMinhQuangBlog%2Fmedia%2Fposts%2F11%2F1_wdNsCBMAtWRkT7ppVEVf0Q.png&amp;description=JavaScript%20Asynchronous%20Programming%20(Promises%20v%C3%A0%20Async%2FAwait)" class="js-share icon brands fa-pinterest" rel="nofollow noopener noreferrer"><span class="label">Pinterest</span> </a><a href="https://mix.com/add?url=https%3A%2F%2FNguyenMinh10042003.github.io%2FNguyenMinhQuangBlog%2Fjavascript-asynchronous-programming-promises-va-asyncawait.html" class="js-share icon brands fa-mix" rel="nofollow noopener noreferrer"><span class="label">Mix</span> </a><a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2FNguyenMinh10042003.github.io%2FNguyenMinhQuangBlog%2Fjavascript-asynchronous-programming-promises-va-asyncawait.html" class="js-share icon brands fa-linkedin" rel="nofollow noopener noreferrer"><span class="label">LinkedIn</span> </a><a href="https://buffer.com/add?text=JavaScript%20Asynchronous%20Programming%20(Promises%20v%C3%A0%20Async%2FAwait)&amp;url=https%3A%2F%2FNguyenMinh10042003.github.io%2FNguyenMinhQuangBlog%2Fjavascript-asynchronous-programming-promises-va-asyncawait.html" class="js-share icon brands fa-buffer" rel="nofollow noopener noreferrer"><span class="label">Buffer</span> </a><a href="https://api.whatsapp.com/send?text=JavaScript%20Asynchronous%20Programming%20(Promises%20v%C3%A0%20Async%2FAwait) https%3A%2F%2FNguyenMinh10042003.github.io%2FNguyenMinhQuangBlog%2Fjavascript-asynchronous-programming-promises-va-asyncawait.html" class="js-share icon brands fa-whatsapp" rel="nofollow noopener noreferrer"><span class="label">WhatsApp</span></a></div><div class="post__bio"><img src="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/media/website/315051163_676409890517089_7907966800036286213_n-2.jpg" loading="lazy" height="200" width="200" alt="Nguyen Minh Quang"><div><h3><a href="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/authors/nguyen-minh-quang/" class="invert" rel="author">Nguyen Minh Quang</a></h3></div></div></footer></article><div class="comments-area"><div class="post__inner"></div></div></div></div><div id="sidebar"><div class="inner"><nav id="menu"><header class="major"><h2>Menu</h2></header><ul><li><a href="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/" target="_self">Home</a></li><li><a href="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/authors/nguyen-minh-quang/" target="_self">Blog</a></li></ul></nav><section><header class="major"><h2>Get in touch</h2></header><p>Sed varius enim lorem ullamcorper dolore aliquam aenean ornare velit lacus,ac varius enim lorem ullamcorper dolore. Proin sed aliqu facilisis ante interdum. Sed nulla amet lorem feugiat tempus aliquam.</p><ul class="contact"><li class="icon solid fa-envelope"><a href="#">information@untitled.tld</a></li><li class="icon solid fa-phone">(000) 000-0000</li><li class="icon solid fa-home">1234 Somewhere Road #8254<br>Nashville, TN 00000-0000</li></ul></section><footer id="footer"><p class="copyright">Edit by 2180606468 Nguyen Minh Quang<br>Design by Publii</p></footer></div></div></div><script src="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/assets/js/jquery.min.js?v=7c14a783dfeb3d238ccd3edd840d82ee"></script><script src="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/assets/js/browser.min.js?v=c07298dd19048a8a69ad97e754dfe8d0"></script><script src="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/assets/js/breakpoints.min.js?v=81a479eb099e3b187613943b085923b8"></script><script src="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/assets/js/util.min.js?v=cbdaf7c20ac2883c77ae23acfbabd47e"></script><script src="https://NguyenMinh10042003.github.io/NguyenMinhQuangBlog/assets/js/main.min.js?v=08add7f6d435054ad38ec38d7cf8be40"></script><script>var images=document.querySelectorAll("img[loading]");for(var i=0;i<images.length;i++){if(images[i].complete){images[i].classList.add("is-loaded")}else{images[i].addEventListener("load",function(){this.classList.add("is-loaded")},false)}};</script></body></html>